# DBMS Applications
- Set of programs that manage a collection of data (Database) and it's efficient storage/retrieval and security.

- The central aspect of these programs is the data itself.
- DBMS provide an abstraction layer over a collection of data so programmer's do not have to worry about the details of how the data is stored and organized.

Examples:
- Enterprise Information
	° Sales: For customer, product, and purchase information.
	° Accounting: For payments, receipts, account balances, assets, and other ac-
	counting information.
	° Human resources: For information about employees, salaries, payroll taxes, and
	benefits, and for generation of paychecks.

- Banking and Finance
	° Banking: For customer information, accounts, loans, and banking transactions.
	° Credit card transactions: For purchases on credit cards and generation of monthly statements.
	° Finance: For storing information about holdings, sales, and purchases of financial instruments such as stocks and bonds; also for storing real-time market
	data to enable online trading by customers and automated trading by the firm.


- Mainly 2 ways databases are used:
		1. **Online transaction processing**: large number of users access small data out of the database and also make small updates/changes. 
		2. **Data analytics**: Processing of data to draw conclusions, which then drive business decisions. Rules and patterns are discovered from data and *predictive models* are created, which are then fed with features or attributes as inputs and then predictions are outputted by the model.
		


# Purpose of DBMS

- To understand the purpose of a DMBS, we understand a more caveman style of data storage: **file-processing system**

- Basically you store records as permanent/temp files in the OS. Then create programs that  update/change/concatenate to those files. Pretty straightforward. 

- The problems with a system like this is:
	- Data redundancy and inconsistency. Since different programmers create the files and application programs over a long period, the various files are likely to have different structures, and the programs may be written in several programming languages. Moreover, the same information may be duplicated in several places (files). For example, if a student has a double major (say, music and mathematics), the address and telephone number of that student may appear in a file that consists of student records of students in the Music department and in a file that consists of student records of students in the Mathematics department. This redundancy leads to higher storage and access cost. In addition, it may lead to data inconsistency; that is, the various copies of the same data may no longer agree. For example, a changed student address may be reflected in the Music department records but not elsewhere in the system.
	- Difficulty in accessing data. Suppose that one of the university clerks needs to find out the names of all students who live within a particular postal-code area. The clerk asks the data-processing department to generate such a list. Because the designers of the original system did not anticipate this request, there is no application program on hand to meet it. There is, however, an application program to generate the list of all students. The university clerk now has two choices: either obtain the list of all students and extract the needed information manually or ask a programmer to write the necessary application program. Both alternatives are obviously unsatisfactory. Suppose that such a program is written and that, several days later, the same clerk needs to trim that list to include only those students who have taken at least 60 credit hours. As expected, a program to generate such a list does not exist. Again, the clerk has the preceding two options, neither of which is satisfactory. The point here is that conventional file-processing environments do not allow needed data to be retrieved in a convenient and efficient manner. More responsive data-retrieval systems are required for general use.
	- Integrity problems. The data values stored in the database must satisfy certain types of consistency constraints. Suppose the university maintains an account for each department, and records the balance amount in each account. Suppose also that the university requires that the account balance of a department may never fall below zero. Developers enforce these constraints in the system by adding appro- priate code in the various application programs. However, when new constraints are added, it is difficult to change the programs to enforce them. The problem is compounded when constraints involve several data items from different files.
	- Atomicity problems. A computer system, like any other device, is subject to failure. In many applications, it is crucial that, if a failure occurs, the data be restored to the 1.2 Purpose of Database Systems 7 consistent state that existed prior to the failure. Consider a banking system with a program to transfer $500 from account A to account B. If a system failure occurs during the execution of the program, it is possible that the $500 was removed from the balance of account A but was not credited to the balance of account B, resulting in an inconsistent database state. Clearly, it is essential to database consistency that either both the credit and debit occur, or that neither occur. That is, the funds transfer must be atomic— it must happen in its entirety or not at all. It is difficult to ensure atomicity in a conventional file-processing system.
	- Concurrent-access anomalies. For the sake of overall performance of the system and faster response, many systems allow multiple users to update the data simulta- neously. Indeed, today, the largest internet retailers may have millions of accesses per day to their data by shoppers. In such an environment, interaction of concur- rent updates is possible and may result in inconsistent data. Consider account A, with a balance of $10,000. If two bank clerks debit the account balance (by say $500 and $100, respectively) of account A at almost exactly the same time, the re- sult of the concurrent executions may leave the account balance in an incorrect (or inconsistent) state. Suppose that the programs executing on behalf of each with- drawal read the old balance, reduce that value by the amount being withdrawn, and write the result back. If the two programs run concurrently, they may both read the value $10,000, and write back $9500 and $9900, respectively. Depending on which one writes the value last, the balance of account A may contain either $9500 or $9900, rather than the correct value of $9400. To guard against this possibility, the system must maintain some form of supervision. But supervision is difficult to provide because data may be accessed by many different application programs that have not been coordinated previously. As another example, suppose a registration program maintains a count of students registered for a course in order to enforce limits on the number of students registered. When a student registers, the program reads the current count for the courses, verifies that the count is not already at the limit, adds one to the count, and stores the count back in the database. Suppose two students register concurrently, with the count at 39. The two program executions may both read the value 39, and both would then write back 40, leading to an incorrect increase of only 1, even though two students successfully registered for the course and the count should be 41. Furthermore, suppose the course registration limit was 40; in the above case both students would be able to register, leading to a violation of the limit of 40 students.
	- Security problems. Not every user of the database system should be able to access all the data. For example, in a university, payroll personnel need to see only that part of the database that has financial information. They do not need access to information about academic records. But since application programs are added to the file-processing system in an ad hoc manner, enforcing such security constraints is difficult.



> ***So how do DBMS solve this issues with a normal file-processing system???***
# 1.3 View of Data

## 1.3.1 Data models
- **Data model**: A conceptual tool for describing data, data relationships, data semantics, and consistency constraints.

>[!Success] Side note
>Data essentially is stored in disks, at the low level, using different data structures like B+ trees and hashmaps; no matter the DBMS


- **Relational Model:** Record based model, fixed-format records of several types. Database has tables, each table has multiple columns and each column has a unique name. Tables are known as **relations**. Each table contains records of a particular type. (Each row is one record). This is the most common data model. 
- **Entity-Relationship Model**: ER model uses collection of basic objects, called entities; and relationships among these objects. An entity is a "thing" or "object" in the real world that is distinguishable from other objects. 
- **Semi-structured Data model:** Basically data items of the same type may have different attributes, unlike the above 2 where all data of the same type has a fixed, same format. Example: JSON and XML are used for semi-structured data representations. 
- **Object-Based Data Model:** Pretty much relational model, but we can also store procedures which the DBMS can execute. 

## 1.3.2 Relational Data model
- Basically Tables with records. 
- Each row is a record item.
- Each column is one certain attribute of the record items.

![[Pasted image 20260215201154.png]]
*The instructor table*
![[Pasted image 20260215201225.png]]
*The department table*


## 1.3.3 Data abstraction
- To save users of DBMS from the complex structures used to store data there are many levels of data abstraction:
	- **Physical Level:** *How* the data is actually stored on the low-level. 
	- **Logical Level:** *What* data are stored in the database and what relationships exist among those data. 
	- **View Level:** Only *part* of the entire database. Logical level uses simpler structures but the variety and amount of data remains. Many users don't need all that, instead they need to access focused parts of the database. The view level of abstraction exists to simplify their interaction with the system. The system may provide many views for the same database. 
![[Pasted image 20260215201912.png]]
*relationsship between the 3 levels*

Programming language analogy:
- The compiler hides the lower level details of machine language or sequence of bytes from person writing the code. This lower level is the physical layer. 
- The programming language with its data types is basically the logical layer with all the relation ships between different tables or record types. 
- Finally we have users using the finished program who do not know the data type details that are underlying the program. This is the view level. 


## 1.3.4 Instances and Schema
- The collection of data stored in a database at one given point in time is called an **instance** of the database.
- The overall design of the database is called the **schema** of the database.

- Programming language analogy: Variable declarations are the schema, meanwhile the values of the variables at any given instant is the instance of the database schema.

- There are multiple schemas: logical, physical, view layer schemas.


# 1.4 Database Languages

- DBMS defines a DATA DEFINITION LANGUAGE to specify the database schema and a DATA MANIPULATION LANGUAGE (DML) to express queries or updates. Usually these are parts of the same Language. 
- Example: SQL
- Almost all database systems employ the SQL language.

## 1.4.1 Data Definition Language
- The storage structure and access methods used by the DBMS is defined by a special type of DDL: Data storage and definition language. The statements define the implementation details of the database schemas.

- We can define constraints on the stored data. These constraints are always tested against the data every time the database is updated. 

**Domain Constraints:** Domain of possible values must be associated with every attribute. Defines the values an attribute can basically take. 

**Referential Integrity:** Basically a value that appears for an attribute for some record type should also appear for an attribute in another record type. Example: a department name (`dept_name`) that appears in a course record should also appear for a `dept_name` attribute in a department (`department`) record. When a violation of this happens, usually the action causing the violation is rejected. 

**Authorization:** We may allow different users different access on various data in the DB. These are called authorizations. Examples: read (but no modifications), insert (no modification of old data), update (modification but no deletion), delete (deletion of data). We can assign all, none, or a combo of these authorization to a user.

- The output of a DDL is metadata about the data and is placed inside the data dictionary - which is a special type of table that only the DBMS can access and update. The DBMS consults the data dictionary before reading or modifying actual data. 

## 1.4.2 The SQL DDL

- SQL has a DDL that allows to define tables with data types and integrity constraints like:
```sql
create table department
	(dept_name    char(20),
	 building     char(15),
	 budget       numeric(12,2));

```

- We can specify that the `dept_name` attribute is a primary key, which means that no two departments can have the same department name. Or something like a value for `dept_name` appearing in any record in the instructor table should also appear for `dept_name` of some record in the department table. These are examples of integrity constraints. 

## 1.4.3 Data Manipulation Language

- Access or manipulate data as organized by the appropriate data model. 
	- Retrieval of info
	- Insertion of new info
	- Deletion of info
	- Modification of info

- 2 types of data manipulation language:
	- **Procedural DMLs**: require a user to specify what data are needed and how to get those data. 
	- **Declarative DMLs** require a user to specify what data are needed without specifying how to get those data.

- **Query:** Statement requesting the retrieval of information. The portion of a DML that involves information retrieval is called *query language*. 

- The most widely used query language is once again, SQL.

- The **Query Processor** (covered later) converts queries into sequences of actions on the physical level of the DBMS. 

## 1.4.4 The SQL Data Manipulation Language

- SQL query language is Declarative. 
- Takes 1 or more tables as inputs and always returns a single table. 

- Example:
```sql
select instructor.name
from instructor
where instruction.dept_name = 'History';
```

returns a table with a single column, named *name* and a set of rows. 

- Queries may involve info from more than one table like:
```sql
select instructor.ID, department.dept_name
from instructor, department
where instructor.dept_name = department.dept_name and department.budget > 95000;
```
return table with 2 columns named (*ID, dept_name*) with rows. 

## 1.4.5 Database Access from Application programs

- Declarative query languages such as SQL are not Turing complete. 
- Many operations including communication over a network need to be implemented in the *host* language such as C/C++ with SQL queries embedded that access the data in the database. 

- Programs used to interact with the DB in this manner are **Application programs**. 

- DML statements need to be sent from the host to the database system where they will be executed. This is done by using an application program interface (set of procedures) that can be used to send DML and DDL statements to the database & retrieve the results.

- The Open Database Connectivity (ODBC) standard defines application program interfaces for use with C and several other languages. JDBC defines something similar for Java. 





