## Complex state

1. Usually state is more complex than just one single integer variable and can be many different things like below:

```jsx
const App = () => {
  const [clicks, setClicks] = useState({
    left: 0, right: 0
  })

  const handleLeftClick = () => {
    const newClicks = { 
      left: clicks.left + 1, 
      right: clicks.right 
    }
    setClicks(newClicks)
  }

  const handleRightClick = () => {
    const newClicks = { 
      left: clicks.left, 
      right: clicks.right + 1 
    }
    setClicks(newClicks)
  }

  return (
    <div>
      {clicks.left}
      <button onClick={handleLeftClick}>left</button>
      <button onClick={handleRightClick}>right</button>
      {clicks.right}
    </div>
  )
}
```

>[!warning] Side note on tailwindcss styling
>All classes must be applied to the jsx tags and not component tags.

2. The above new object assignment can be replaced with the new spread syntax style introduced in 2018 like this:
```jsx
const handleLeftClick = () => {
  const newClicks = { 
    ...clicks, 
    left: clicks.left + 1 
  }
  setClicks(newClicks)
}

const handleRightClick = () => {
  const newClicks = { 
    ...clicks, 
    right: clicks.right + 1 
  }
  setClicks(newClicks)
}
```
`{clicks}` creates a new object that has copies of all of the properties of the clicks object. When we give it a parameter that the original object contained, it will replace the original value with the new one.

3. NEVER EVER modify state variables directly. It is forbidden. Can lead to bad side effects.

---
 We must decide how to organize our state variables to reduce debugging stress. Can refer to this: **[React docs][https://react.dev/learn/choosing-the-state-structure]** for more information.

### Some notes on the above

1. Doing something like this 
```jsx
function Message({ messageColor }) {  

const [color, setColor] = useState(messageColor);
```
can cause confusion because if the parent passes a different color, the state variable color will not be updated because it is only updated the first render and that becomes it's initial value.

- If two state variables always update together, consider merging them into one.
- Choose your state variables carefully to avoid creating “impossible” states.
- Structure your state in a way that reduces the chances that you’ll make a mistake updating it.
- Avoid redundant and duplicate state so that you don’t need to keep it in sync.
- Don’t put props _into_ state unless you specifically want to prevent updates.
- For UI patterns like selection, keep ID or index in state instead of the object itself.
- If updating deeply nested state is complicated, try flattening it.

---

### Handling arrays


## Update of the state is asynchronous

1. Basically, update of state happens asynchronously, i.e, not immediately but "at some point" after the current component function is finished, before the component is rendered again.

## Conditional Rendering
Render different things based on different conditions:

```jsx
const History = ({allClicks}) =>{

if(allClicks.length == 0){

return (

<Display clickValue = "The app is used by pressing the buttons"/>

)

}

  

return (

<Display clickValue = {allClicks.join(' ')}></Display>

)

}
```

1. There are other ways to do conditonal rendering in react, will be looked at in part 2

## Old react
Older react code did not have state hooks and instead had class based components like this:
```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  }

  componentDidMount() {
    document.title = `Count: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`;
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

This will be explored further later on.


## Debugging react apps
1. Old school print based debugging is always a good idea
2. We can put `debugger` in our script to pause for debugging
3. Then we can go to the console and inspect the variables
4. Once done debugging, we can remove the `debugger` command 
5. We can also add breakpoints through the sources tab and the values of the component's variables can be inspected in the Scope section
6. React dev tools extension is very helpful

## Rules of Hooks
1. All `use` based functions in react are usually hooks.
2. `useState`, `useEffect`, etc. should not be called from inside loops or conditionals to preserve the order of hooks in React's "fiber" object for that component. 
   If this order breaks, the app behaves erratically.

## More Event Handling
1. Event handler must be always a function or a reference to a function. **Nothing Else.**

---
## A function that returns a function
```jsx
const App = () => {
  const [value, setValue] = useState(10)

  const hello = () => {    const handler = () => console.log('hello world')    return handler  }
  return (
    <div>
      {value}
      <button onClick={hello()}>button</button>
    </div>
  )
}
```
This is valid even though onClick gets a function *call* as a value. (Why?)

What's the point of this concept?

Let's change the code a tiny bit:

```js
const App = () => {
  const [value, setValue] = useState(10)

  const hello = (who) => {    const handler = () => {      console.log('hello', who)    }    return handler  }
  return (
    <div>
      {value}
      <button onClick={hello('world')}>button</button>      <button onClick={hello('react')}>button</button>      <button onClick={hello('function')}>button</button>    </div>
  )
}
```

Now the application has three buttons with event handlers defined by the _hello_ function that accepts a parameter.

The first button is defined as

```js
<button onClick={hello('world')}>button</button>
```

The event handler is created by _executing_ the function call _hello('world')_. The function call returns the function:

```js
() => {
  console.log('hello', 'world')
}
```

The second button is defined as:

```js
<button onClick={hello('react')}>button</button>
```

The function call _hello('react')_ that creates the event handler returns:

```js
() => {
  console.log('hello', 'react')
}
```

Both buttons get their individualized event handlers.

Functions returning functions can be utilized in defining generic functionality that can be customized with parameters. The _hello_ function that creates the event handlers can be thought of as a factory that produces customized event handlers meant for greeting users.

Our current definition is slightly verbose:

```js
const hello = (who) => {
  const handler = () => {
    console.log('hello', who)
  }

  return handler
}
```

Let's eliminate the helper variables and directly return the created function:

```js
const hello = (who) => {
  return () => {
    console.log('hello', who)
  }
}
```

Since our _hello_ function is composed of a single return command, we can omit the curly braces and use the more compact syntax for arrow functions:

```js
const hello = (who) =>
  () => {
    console.log('hello', who)
  }
```

Lastly, let's write all of the arrows on the same line:

```js
const hello = (who) => () => {
  console.log('hello', who)
}
```

We can use the same trick to define event handlers that set the state of the component to a given value. Let's make the following changes to our code:

```js
const App = () => {
  const [value, setValue] = useState(10)
  
  const setToValue = (newValue) => () => {    console.log('value now', newValue)  // print the new value to console    setValue(newValue)  }  
  return (
    <div>
      {value}
      <button onClick={setToValue(1000)}>thousand</button>      <button onClick={setToValue(0)}>reset</button>      <button onClick={setToValue(value + 1)}>increment</button>    </div>
  )
}
```

When the component is rendered, the _thousand_ button is created:

```js
<button onClick={setToValue(1000)}>thousand</button>
```

The event handler is set to the return value of _setToValue(1000)_ which is the following function:

```js
() => {
  console.log('value now', 1000)
  setValue(1000)
}
```

The increase button is declared as follows:

```js
<button onClick={setToValue(value + 1)}>increment</button>
```

The event handler is created by the function call _setToValue(value + 1)_ which receives as its parameter the current value of the state variable _value_ increased by one. If the value of _value_ was 10, then the created event handler would be the function:

```js
() => {
  console.log('value now', 11)
  setValue(11)
}
```

Using functions that return functions is not required to achieve this functionality. Let's return the _setToValue_ function which is responsible for updating state into a normal function:

```js
const App = () => {
  const [value, setValue] = useState(10)

  const setToValue = (newValue) => {
    console.log('value now', newValue)
    setValue(newValue)
  }

  return (
    <div>
      {value}
      <button onClick={() => setToValue(1000)}>
        thousand
      </button>
      <button onClick={() => setToValue(0)}>
        reset
      </button>
      <button onClick={() => setToValue(value + 1)}>
        increment
      </button>
    </div>
  )
}
```

We can now define the event handler as a function that calls the _setToValue_ function with an appropriate parameter. The event handler for resetting the application state would be:

```js
<button onClick={() => setToValue(0)}>reset</button>
```

Choosing between the two presented ways of defining your event handlers is mostly a matter of taste.

---

## Passing Event handlers to child components

1. We did this before. We pass some onEvent as prop parameters

## Do Not Define components within components

1. There is nothing technically wrong since nested functions are a valid thing, however, this does not provide any benefit and can lead to confusion and problems. Must avoid.




